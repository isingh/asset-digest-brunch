// Generated by CoffeeScript 1.8.0
var AssetDigest, crypto, fs, glob, path;

crypto = require('crypto');

fs = require('fs');

glob = require('glob');

path = require('path');

AssetDigest = (function() {
  AssetDigest.prototype.brunchPlugin = true;

  function AssetDigest(config) {
    var key, providedConfig, value, _ref, _ref1;
    this.config = config;
    this.options = {
      patternForSubstitution: /DIGEST/g,
      prefixForSubstitution: '',
      patternForFilesForDigest: null,
      manifestPath: null,
      retainOriginal: false
    };
    providedConfig = (_ref = (_ref1 = this.config.plugins) != null ? _ref1.assetDigest : void 0) != null ? _ref : {};
    for (key in providedConfig) {
      value = providedConfig[key];
      this.options[key] = value;
    }
  }

  AssetDigest.prototype.onCompile = function() {
    return this._fileDigestMap(this._filesForDigest());
  };

  AssetDigest.prototype._fileDigestMap = function(filesForDigest) {
    var file, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = filesForDigest.length; _i < _len; _i++) {
      file = filesForDigest[_i];
      console.log(file);
      _results.push(console.log(this._digestForFile(file)));
    }
    return _results;
  };

  AssetDigest.prototype._filesForDigest = function() {
    var file, fileName, filesForDigest, _i, _len, _ref;
    filesForDigest = [];
    _ref = this._allPublicFiles();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      fileName = path.basename(file, path.extname(file));
      if (this._matchesPattern(fileName, this.options.patternForFilesForDigest) && !this._isDigestFile(fileName)) {
        filesForDigest.push(file);
      }
    }
    return filesForDigest;
  };

  AssetDigest.prototype._digestForFile = function(file) {
    return fs.readFile(file, function(err, data) {
      return this._checksum(data);
    });
  };

  AssetDigest.prototype._checksum = function(str, algorithm, encoding) {
    return crypto.createHash(algorithm || 'md5').update(str, 'utf8').digest(encoding || 'hex');
  };

  AssetDigest.prototype._matchesPattern = function(stringForTest, pattern) {
    if (pattern == null) {
      return true;
    }
    return pattern.test(stringForTest);
  };

  AssetDigest.prototype._isDigestFile = function(fileName) {
    return /-[a-fA-F0-9]{8}$/.test(fileName);
  };

  AssetDigest.prototype._allPublicFiles = function() {
    var filename, publicFiles, _i, _len, _ref;
    publicFiles = [];
    _ref = glob.sync(this._publicPath());
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filename = _ref[_i];
      if (fs.statSync(filename).isFile()) {
        publicFiles.push(filename);
      }
    }
    return publicFiles;
  };

  AssetDigest.prototype._publicPath = function() {
    var _ref, _ref1;
    return "" + ((_ref = (_ref1 = this.config.paths) != null ? _ref1["public"] : void 0) != null ? _ref : 'public') + "/**";
  };

  return AssetDigest;

})();

module.exports = AssetDigest;
